---
title: '쌍선형 페어링'
description: '- 타원 곡선의 점의 덧셈과, 스칼라 곱에 대한 지식 - x*G=P 일때 P와 G를 알때 x를 구하는게 불가능 하다라는 사전 지식 - G는 생성원으로 G에 스칼라 곱을 해서 유한체의 모든 원소를 만들 수 있음 - precompiles에 대한 지식 - 자세하게 말하지는 않겠지만 일종의 빌트인 함수 라고 생각하면됨 이더...'
pubDate: '2025-04-13'
tags:
  - 'zk'
  - '수학'
  - '암호학'
---
# 사전 지식

- 타원 곡선의 점의 덧셈과, 스칼라 곱에 대한 지식
- x*G=P 일때 P와 G를 알때 x를 구하는게 불가능 하다라는 사전 지식
- G는 생성원으로 G에 스칼라 곱을 해서 유한체의 모든 원소를 만들 수 있음
- precompiles에 대한 지식
   - 자세하게 말하지는 않겠지만 일종의 빌트인 함수 라고 생각하면됨
이더리움에서 미리 만들어준 함수로써 이중에서 BLS128에 대해서 연산을 할 수있는 함수가 존재함

# How bilinear pairings work

먼저 `bilinear` 의 의미는

함수가 2개의 인자를 받을 때 하나가 상수가 하나가 변수일때 함수의 출력이 변수에 따라 선형적으로 변하는것을 의미함

ex) f(x,y)가  `bilinear` 하다면
c가 상수 일때 z= f(x,c)는 x에 대해서 선형적이고, z=f(c,y)는 y에 대해서 선형적이라고 함

그렇기 때문에 bilinear pairing를 가지는 타원곡선은 다음과 같은 성질를 가진다

$$f(aG,bG) = f(abG,G) = f(G,Gab)$$

pq=r 이라고 가정 하고

$$
\begin{align*}
P = pG\\
Q = qG\\
R = rG\\
\end{align*}
$$

위와 같은 식이 존재 할때

증명자는 검증자에게 P와 Q의 이산로그값 즉 p 와 q의 곱이 R의 이산 로그값과 같다는걸 증명 하고 싶을때

다음과 같은 함수가 필요함

$$f(P,Q) =R$$

하지만 보통 표현 하는 방식은

$$f(P,Q)=f(R,G)$$ 형태로 표현을 한다고 함

즉 bilinear pairing 두개의 타원곡선 상의 점을 연결해서 두점의 이산로그 값의 곱에 해당 되는 값을 얻는 함수이다.

> 정확히는 위의 공식은 대칭 페어링에서 적용 되는 공식입니다

다른 문서의 정의에 따르면  bilinear pairing은 bilinear map이라고도 불리고

2개의 순환부분군의 타원곡선에서 2개의 점($$G_1$$ 과 $$G_2$$ )를 하나의 $$G_T$$ 의 요소로 매핑을 하는것을 bilinear pairing 또는 bilinear map이라고 합니다.

+ 생각정리

   그렇다면 이게 필요한것은 증명 하고 싶은건 어떤 2개의 이산로그값의 곱 
즉 타원곡선 암호로 치면 a,b라는 개인키의 곱이 r과 같다는 걸 검증 하고 싶을때 쓰는건가?

즉 pq=r을 증명 하고 싶지만 p,q를 밝히고 싶지 않기 위해서 사용 하는 일종의 얘도 hiding 함수인가?

### 추가적인 설명

개인적으로 수학적 이해가 부족해서인지 정확히 뭔지 이해를 하기 힘들어서 예시와 활용을 찾아 봤습니다.

먼저 DH문제와 Gap Group을 알게 되면 paring 함수의 필요성을 이해할 수 있게 됩니다.

### DH 프로토콜

![Image.png](https://res.craft.do/user/full/8a20dcc5-f8f2-2a62-7c8a-b380291da7e1/doc/F5EFA47B-8345-4651-9A5A-02E4C5F31983/54274E47-5355-4608-B8B4-08DA10EFAE41_2/8RJwhfoxfJRU67SiZEVfbDwvExhhat2umloTHxiIt4kz/Image.png)

위에서 볼 수 있듯이 DH 프로토콜은 비밀 키과 공유키가 있을때 공유 비밀을 만드는 프로토콜 입니다.

그런데 이때 이전에 늘 설명 했듯이 $$G^a$$ 의 값에서 a를 유추 할 수는 없어야 합니다 이를 DLP 이산로그 문제라고 부릅니다.

하지만 만약 A,B를 알고 있을때 두 값을 통해서 $$G^a^b$$ 를 계산 할 수 없을까요? 이를 DH 문제라고 합니다.

현재 까지로는 DLP를 풀수 없으면 DH 문제에 대한 해법이 없다고 합니다.

이를 타원 곡선 형식으로 풀어 보면

$$A=aG , B=bG$$ 다음 과 같은 값이 있을때

A,B를 가지고 $$abG$$ 를 구할 수 있는가와 같게 됩니다.

이를 Computational Diffie-Hellman(이후 CDH) Problem 라고 부릅니다.

그리도 추가적으로 만약 계산을 하지 않고 그냥

a,b를 모른체 aG,bG 값을 받은 상태애서
abG를 계산 할 수는 없지만

어떤한 cG가 abG가 일치 하는걸 알 수있는가에 대한 문제가 있습니다.

헤당 문제를 Decisional Diffie-Hellman(이후 DDH) Problem 이라고 부릅니다

당연하 CDH를 풀 수 있으면 DDH를 풀수 있지만

그 역은 성립 하지 않습니다.

이때 타원곡선을 잘 만들면
DDH 문제를 효율적으로 풀수 있고 CDH는 어렵게 만들수 있는데 이런 타원곡선 그룹을

Gap Group이라고 합니다.

Gap Group에서는 다음과 같은 서명로직이 가능한데

![Image.png](https://res.craft.do/user/full/8a20dcc5-f8f2-2a62-7c8a-b380291da7e1/doc/F5EFA47B-8345-4651-9A5A-02E4C5F31983/FED817E7-7EA6-41EB-992F-BBB15BA2B6D5_2/yW62ys4RT1QXrbgXmNd3xeqVCPXdWo34JTI2ajB5Rdsz/Image.png)

DH Problem은 어렵고, DDH Problem은 쉬운 타원곡선 그룹 Gap Group을 GG라고 하고 GG의 generator(base point)를 G라고 하고

서명 할 메세지를 해싱해서 H로 매핑을 하게 되는데 이때

hG=H가 된다.

그리고 서명은 xH가 된다.

그러면 bob이 서명을 검증 하기 위해서 받는 값은

xG,hG,xH=S 이게 되는데 그러면

bob이 해야 하는 검증은 위에 가지 값으로

xhG=S를 검증을 해야 한다.

이때 쓰이는 함수가 pairing 함수이다.

e: G1 X G2 → GT 라는 페어링 함수가 존재 하고

e(xG,hG) == e(G,xhG) 를 검증 하며 되고

G는 비대칭군에서는

G1,G2를 사용 하도록 해서

e(xG1,hG2) == e(G1,S) 이고 S는 xhG2와 같기 때문에

적법한 서명이라면.  xG,hG,xH 값과 페어링을 통해서 서명을 검증 할 수 있게 된다.

### What is e(P,Q) returning?

해당 문서에서는 정확히 e가 어떤 함수인지는 블랙박스로 둔다고 함

하지만 해당 함수가 반환하는 반환 값은 유한 순환군의 요소라고 하고 아래의 속성을 가짐

- $$G_T$$ 는 순환군이며 닫힌 이항연산을 가짐
- $$G_T$$ 의 이항연산은 결합법칙이 성림
- 항등원을 가짐
- $$G_T$$ 의 모든 요소는 역원을 가짐
- 순환군이기 때문에 생성원을 가짐
- $$G_T$$ 와 순환군은 서로 동형이라서 유한 순한군의 하나의 요소를 $$G_T$$ 에 매핑 하는 방법이 존재함

$$G_T$$ 는 12차원의 스칼라값이며 타원곡선의 군이 아님

그리고 대칭군과 비대칭 군이 존재 하는데

대칭군은

$$e(aG,bG)=e(abG,G)$$ 다음과 같은 식에서 G가 둘다 같은 생성원과 같은 타원 곡선 군을 사용하고

비대칭군은 다른 타원곡선군과 다른 생성원을 사용하는데 이때 두 군의 order가 같을때 pairing을 만드는게 쉽다고 합니다.

즉 다음과 같은 식이 있을때

$$e(a,b) \rightarrow a \in G_1, b \in G_2 c \in G_T$$

G1,G2,GT 3개의 군은 다 다른군이지만 order는 같으며

$$e(aG_1,bG_2) = e(abG_1,G_2) = e(G_1,abG_2)$$가 성립함

## Field Extensions and the `G2` point in Python

이더리움에서는 G2를 확장체에 존재하는 타원곡선을 사용함

확장체는 개념이 어렵기 때문에 그냥 G2의 점의 x,y 좌표는 2차원의 값을 가진다고 생각하면 됨

Ex) ((x1,y1),(x2,y2))

파이썬 코드로 보면 다음과 같음

```python
from py_ecc.bn128 import G1, G2, pairing, add, multiply, eq

print(G1)
# (1, 2)
print(G2)
#((10857046999023057135944570762232829481370756359578518086990519993285655852781, 11559732032986387107991004021392285783925812861821192530917403151452391805634), (8495653923123431417604973247489272438418190587263600148770280649306958101930, 4082367875863433681332203403145435568316851327593401208105741076214120093531))
```

G1,G2의 order는 같으며 G2 역시 기존에 우리가 봐왔던 다른 순환군과 같은 기능을 함

```python
# 스칼라 곱
print(eq(add(G1, G1), multiply(G1, 2)))
# True
print(eq(add(G2, G2), multiply(G2, 2)))
# True
```

하지만 이때 같은 군의 요소끼리만 더할 수 있음

```python
add(G1, G2) # TypeError
```

그리고 파이썬코드로 위에서 설명 했던

$$PQ=R$$ 가 성립하는지 검증 할 수 있음

```python
from py_ecc.bn128 import G1, G2, pairing, multiply, eq

P = multiply(G1, 3)
Q = multiply(G2, 8)

R = multiply(G1, 24)

assert eq(pairing(Q, P), pairing(G2, R))
```

그리고 또한 p1p2 =q1q2가 성립 한다는 것을

$$e(P_1,P_2)=e(Q_1,Q_2)$$을 통해서 검증 할 수 있음

```python
from py_ecc.bn128 import G1, G2, pairing, multiply, eq

P_1 = multiply(G1, 3)
P_2 = multiply(G2, 8)

Q_1 = multiply(G1, 6)
Q_2 = multiply(G2, 4)

assert eq(pairing(P_2, P_1), pairing(Q_2, Q_1))
```

### The binary operator of $$G_T$$

GT의 요소들은 곱셈을 통해서 연산되는데 이는 파이썬위에 정의된 일종의 연산이라고 생각해야함

그리고 $$G_T$$ 의 요소들은 지수 연산 처럼 동작함

𝐺𝑇의 원소를 𝑒(3 $$G_2$$, 2$G_1$)로 생성한다고 가정 하면

이 원소를 6𝐺𝑇가 아니라 $$b^6G_T$$ 으로 생각 해야함

```python
from py_ecc.bn128 import G1, G2, pairing, multiply, eq

# 2 * 3 = 6
P_1 = multiply(G1, 2)
P_2 = multiply(G2, 3)

# 4 * 5 = 20
Q_1 = multiply(G1, 4)
Q_2 = multiply(G2, 5)

# 13 * 2 = 26
R_1 = multiply(G1, 13)
R_2 = multiply(G2, 2)

# b ^ {2 * 3} * b ^ {4 * 5} = b ^ {13 * 2}
# b ^ 6 * b ^ 20 = b ^ 26

assert eq(pairing(P_2, P_1) * pairing(Q_2, Q_1), pairing(R_2, R_1))
```

## Bilinear Pairings in Ethereum

이더리움에서는 EIP 197에서 정의 된 precompile 함수를 통해서 검증을 할 수있는데

이때 이 함수는 페어링을 계산해서 값을 주는게 아니라

```python
A₁ = a₁G1
B₁ = b₁G2
A₂ = a₂G1
B₂ = b₂G2
...
Aₙ = aₙG1
Bₙ = bₙG2
```

```python
a₁b₁ + a₂b₂ + ... + aₙbₙ = 0
```

위과 같은 가정을 해서 2번째 공식이 성립하면 1 아니면 0을 반환하는 함수이다.

위에서 설명 한 것과 다르게 왜 실제 이더리움에서는 페어링을 계산 한 값을 주는게 아니라 합을 비교하냐면 대부분의 zk 검증 알고리즘은 실제 페어링 연산 출력 값을 확인 하기 보다는

페어링들 끼리가 같은지 확인을 한다고 한다. (그런데 값을 계산을 안하고 어떻게 같지 확인 하는거지?)

예를 들어서  토네이토 캐시의 Groth16 검증 식은 다음과 같은데

$$
e(A₁, B₂) = e(α₁, β₂) + e(L₁, γ₂) + e(C₁, δ₂)
$$

$$0 = e(−A₁, B₂) + e(\alpha_1, \beta_2) + e(L₁, \gamma_2) + e(C₁, \delta_2)$$

해당 식으로 변환 할 수있고 이는 위에서 설명 한것 처럼 페어링들의 합이 0인것만 확인을 하면 된다 아래 사진은 실제 코드와 해당식이 어떻게 매칭 되냐에 대한 그림이다.

![Image.png](https://res.craft.do/user/full/8a20dcc5-f8f2-2a62-7c8a-b380291da7e1/doc/F5EFA47B-8345-4651-9A5A-02E4C5F31983/9C21938B-552B-44FE-AF1F-D038FE71A9BC_2/7stcdktBCUq3l2MlSVCfXfnPyNR69dy5LANSBKJaHz8z/Image.png)

즉 핵심은

$$ab+cd=0$$ 이라는 식이 존재하고 이게 성립되면

bilinear pairing이 존재하는 타원곡선에 대해서

$$A_1B_2 + C_1D_2 = 0 A_1,C_1 \in G_1 , B_2, D_2 \in G_2$$

이 성립 하고

이는

$$e(-aG_1,bG_2) + e(cG_1,dG_2)=0$$ 성립 되면 $$ab+cd=0$$  가 성립 된다는 것을 알 수 있다.

```python
from py_ecc.bn128 import neg, multiply, G1, G2
a = 4
b = 3
c = 6
d = 2
# negate G1 * a to make the equation sum up to 0

print(neg(multiply(G1, a)))
#(3010198690406615200373504922352659861758983907867017329644089018310584441462, 17861058253836152797273815394432013122766662423622084931972383889279925210507)
print(multiply(G2, b))
# ((2725019753478801796453339367788033689375851816420509565303521482350756874229, 7273165102799931111715871471550377909735733521218303035754523677688038059653), (2512659008974376214222774206987427162027254181373325676825515531566330959255, 957874124722006818841961785324909313781880061366718538693995380805373202866))
print(multiply(G1, c))
# (4503322228978077916651710446042370109107355802721800704639343137502100212473, 6132642251294427119375180147349983541569387941788025780665104001559216576968)
print(multiply(G2, d))
# ((18029695676650738226693292988307914797657423701064905010927197838374790804409, 14583779054894525174450323658765874724019480979794335525732096752006891875705), (2140229616977736810657479771656733941598412651537078903776637920509952744750, 11474861747383700316476719153975578001603231366361248090558603872215261634898))
```

## 참고 자료들

[Understanding Zero-Knowledge Proofs: Part 3—Elliptic Curve Cryptography](https://medium.com/@bhaskark2/understanding-zero-knowledge-proofs-part-3-elliptic-curve-cryptography-c52dcc9de4a9)

[0xPARC](https://0xparc.org/blog/zk-pairing-2)

[Elliptic Curve Pairing](https://velog.io/@jdhyun09/Elliptic-Curve-Pairing)

[Pairing-based Cryptography와 BLS signature의 이해 — Part 2](https://medium.com/atomrigslab/pairing-based-cryptography%EC%99%80-bls-signature%EC%9D%98-%EC%9D%B4%ED%95%B4-part-2-ed8d35dbc689)
