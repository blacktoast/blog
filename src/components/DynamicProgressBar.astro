---
import { Icon } from 'astro-icon/components';
import type { MarkdownHeading } from 'astro';

interface Props {
  title: string;
  headings: MarkdownHeading[];
}

const { title, headings } = Astro.props;
---

<div id="dynamic-island-container" class="fixed top-4 left-1/2 -translate-x-1/2 z-50 transition-all duration-300 opacity-0 translate-y-[-20px] pointer-events-none">
  <div id="dynamic-island" class="relative group cursor-pointer">
    
    <div class="dynamic-island-content relative flex flex-col items-center px-4 py-2 bg-background/60 backdrop-blur-md border border-white/10 rounded-xl shadow-lg">
      <div class="dynamic-island-header flex items-center gap-3">
       <div class="relative w-5 h-5 flex items-center justify-center">
          <svg class="w-full h-full -rotate-90" viewBox="0 0 36 36">
          <path
            class="text-muted/20"
            d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
            fill="none"
            stroke="currentColor"
            stroke-width="4"
          />
          <path
            id="progress-circle"
            class="text-accent transition-all duration-100 ease-out"
            stroke-dasharray="0, 100"
            d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
            fill="none"
            stroke="currentColor"
            stroke-width="4"
          />
        </svg>
      </div>
          <span class="text-sm font-medium truncate max-w-[200px] sm:max-w-[300px]">{title}</span>
          {
            headings.length > 0 && (
              <Icon name="lucide:chevron-down" class="w-4 h-4 text-muted-foreground transition-transform duration-300 group-[.open]:rotate-180" />
            )
          }
       </div>

       {
        headings.length > 0 && (
              <div
            id="toc-dropdown"
            class="w-full max-h-0 opacity-0 scale-y-95 pointer-events-none overflow-hidden origin-top transition-[max-height,opacity,transform] duration-[400ms] ease-[cubic-bezier(0.22,1,0.36,1)]"
            aria-hidden="true"
          >
          
            <nav id="toc-nav" class="relative flex flex-col gap-1 pt-1">
              <div
                id="toc-shell-indicator"
                class="absolute left-2 top-0 w-4 h-4 text-accent opacity-0 pointer-events-none transition-[transform,opacity] duration-300 ease-[cubic-bezier(0.22,1,0.36,1)] will-change-transform"
                aria-hidden="true"
              >
                <div class="w-4 h-4 flex items-center justify-center">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M7 18 C 7 18 9 21 12 21 C 15 21 17 18 17 18" />
                    <path d="M17 18 C 20 16 22 13 21 9 C 20.5 7 19 4 12 3 C 5 4 3.5 7 3 9 C 2 13 4 16 7 18" />
                    <path d="M12 3 L 12 10" />      
                    <path d="M15.5 4 L 14.5 10.5" /> 
                    <path d="M8.5 4 L 9.5 10.5" />   
                    <path d="M19 8 L 16.5 13" />     
                    <path d="M5 8 L 7.5 13" />        
                </svg>
                </div>
              </div>
              <div class="w-1 h-1"/>
              {headings.filter(h => h.depth <= 3).map((heading) => (
                <a 
                  href={`#${heading.slug}`} 
                  class:list={[
                    "toc-link relative text-sm px-3 py-1.5 rounded-lg hover:bg-accent/10 transition-colors text-muted-foreground hover:text-foreground truncate block",
                    { "pl-7": heading.depth === 1, "pl-9": heading.depth === 2, "pl-12": heading.depth === 3 }
                  ]}
                  data-slug={heading.slug}
                >
                  {heading.text}
                </a>
              ))}
            </nav>
         </div>
        )
       }
    <!-- Table of Contents Dropdown -->
    
    </div>


  </div>
</div>

<script>

  console.log('DynamicProgressBar script loaded');

  const init=()=>{
        const island = document.getElementById('dynamic-island');
      const progressCircle = document.getElementById('progress-circle');
      const tocDropdown = document.getElementById('toc-dropdown');
      const dynamicContent = document.querySelector('.dynamic-island-content');
      const headerRow = document.querySelector('.dynamic-island-header');
      const tocNav = document.getElementById('toc-nav');
      const shellIndicator = document.getElementById('toc-shell-indicator');
      const tocLinks = Array.from(document.querySelectorAll<HTMLAnchorElement>('#toc-dropdown nav a'));

      const headingTargets = tocLinks
        .map((link) => {
          const slug = link.getAttribute('href')?.slice(1);
          return slug ? document.getElementById(slug) : null;
        })
        .filter((el): el is HTMLElement => Boolean(el));

      let lastActiveSlug : string | null = null;
      let isTocOpen = false;

      if (tocDropdown) {
        tocDropdown.style.maxHeight = '0px';
        tocDropdown.style.width = '0px';
        tocDropdown.style.maxWidth = '0px';
      }

      const getHorizontalPadding = () => {
        if (!dynamicContent) return 0;
        const styles = getComputedStyle(dynamicContent);
        return parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
      };

      const measureCollapsedWidth = () => {
        if (!dynamicContent) return 0;
        const baseWidth = headerRow ? headerRow.getBoundingClientRect().width : dynamicContent.getBoundingClientRect().width;
        return Math.ceil(baseWidth + getHorizontalPadding());
      };

      const measureExpandedWidth = () => {
        if (!dynamicContent || !tocDropdown) return measureCollapsedWidth();

        const prevWidth = tocDropdown.style.width;
        const prevMaxWidth = tocDropdown.style.maxWidth;
        const prevMaxHeight = tocDropdown.style.maxHeight;
        const prevOpacity = tocDropdown.style.opacity;
        const prevTransform = tocDropdown.style.transform;

        tocDropdown.style.width = 'max-content';
        tocDropdown.style.maxWidth = '80vw';
        tocDropdown.style.maxHeight = 'none';
        tocDropdown.style.opacity = '0';
        tocDropdown.style.transform = 'none';

        const dropdownWidth = tocDropdown.scrollWidth;
        const target = Math.max(measureCollapsedWidth(), Math.ceil(dropdownWidth + getHorizontalPadding()));

        tocDropdown.style.width = prevWidth;
        tocDropdown.style.maxWidth = prevMaxWidth;
        tocDropdown.style.maxHeight = prevMaxHeight;
        tocDropdown.style.opacity = prevOpacity;
        tocDropdown.style.transform = prevTransform;

        return target;
      };

      const setDropdownWidth = (opening : boolean) => {
        if (!tocDropdown) return;
        if (opening) {
          tocDropdown.style.width = '100%';
          tocDropdown.style.maxWidth = '80vw';
        } else {
          tocDropdown.style.width = '0px';
          tocDropdown.style.maxWidth = '0px';
        }
      };

      const clampTocHeight = () => {
        if (!tocDropdown) return 0;
        const maxViewportHeight = window.innerHeight * 0.6;
        return Math.min(tocDropdown.scrollHeight, maxViewportHeight);
      };

      const animateTocHeight = (opening : boolean) => {
        if (!tocDropdown) return;
        const startHeight = tocDropdown.offsetHeight;
        const targetHeight = opening ? clampTocHeight() : 0;
        tocDropdown.style.maxHeight = `${startHeight}px`;
        requestAnimationFrame(() => {
          tocDropdown.style.maxHeight = `${targetHeight}px`;
        });
      };

      const playSpring = (direction : 'open' | 'close') => {
        if (!dynamicContent) return;
        dynamicContent.classList.remove('spring-open', 'spring-close');
        requestAnimationFrame(() => {
          dynamicContent.classList.add(direction === 'open' ? 'spring-open' : 'spring-close');
        });
      };

      const openToc = () => {
        
        island?.classList.add('open');
        playSpring('open');
        const collapsedWidth = measureCollapsedWidth();
        const targetWidth = measureExpandedWidth();
        setDropdownWidth(true);
        animateTocHeight(true);
        if (dynamicContent) {
          (dynamicContent as HTMLElement).style.width = `${collapsedWidth}px`;
          requestAnimationFrame(() => {
            (dynamicContent as HTMLElement).style.width = `${targetWidth}px`;
          });
        }
        tocDropdown?.classList.add('opacity-100', 'scale-y-100');
        tocDropdown?.classList.remove('opacity-0', 'scale-y-95', 'pointer-events-none');
        tocDropdown?.setAttribute('aria-hidden', 'false');
      };
      const closeToc = () => {
        island?.classList.remove('open');
        playSpring('close');
        const startWidth = (dynamicContent as HTMLElement).offsetWidth ?? 0;
        const targetWidth = measureCollapsedWidth();
        animateTocHeight(false);
        if (dynamicContent) {
          (dynamicContent as HTMLElement).style.width = `${startWidth}px`;
          requestAnimationFrame(() => {
            (dynamicContent as HTMLElement).style.width = `${targetWidth}px`;
            setDropdownWidth(false);
          });
        } else {
          setDropdownWidth(false);
        }
        tocDropdown?.classList.remove('opacity-100', 'scale-y-100');
        tocDropdown?.classList.add('opacity-0', 'scale-y-95', 'pointer-events-none');
        tocDropdown?.setAttribute('aria-hidden', 'true');
      };
      // Toggle TOC
      island?.addEventListener('click', (e) => {
        e.stopPropagation();
        isTocOpen = !isTocOpen;
        if (isTocOpen) {
          openToc();
        } else {

          closeToc();
        }
      });

      // Close TOC when clicking outside
      document.addEventListener('click', (e : MouseEvent) => {
        if (isTocOpen && !island?.contains(e.target as Node)) {
          isTocOpen = false;
          closeToc();
        }
      });

      // Prevent closing when clicking inside the dropdown links
      tocDropdown?.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Scroll & Progress Logic
      function updateProgress() {
        const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        const scrolled = (winScroll / height) * 100;
        if (progressCircle) {
          progressCircle.setAttribute('stroke-dasharray', `${scrolled}, 100`);
        }
      }

      const moveShellIndicator = (slug : string | null) => {
        if (!shellIndicator || !tocNav) return;
        if (!slug) {
          shellIndicator.style.opacity = '0';
          return;
        }
        const activeLink = tocNav.querySelector<HTMLElement>(`a[data-slug="${slug}"]`);
        if (!activeLink) {
          shellIndicator.style.opacity = '0';
          return;
        }
        const navRect = tocNav.getBoundingClientRect();
        const linkRect = activeLink.getBoundingClientRect();
        const indicatorRect = shellIndicator.getBoundingClientRect();
        const offset = linkRect.top - navRect.top + (linkRect.height - indicatorRect.height) / 2;
        shellIndicator.style.transform = `translateY(${offset}px)`;
        shellIndicator.style.opacity = '1';
      };

      const updateActiveHeading = () => {
        if (!headingTargets.length) return;
        const triggerY = window.innerHeight * 0.3;
        let currentSlug : string | null = headingTargets[0].id;
        for (const el of headingTargets) {
          const rect = el.getBoundingClientRect();
          if (rect.top <= triggerY) {
            currentSlug = el.id;
          } else {
            break;
          }
        }
        if (currentSlug === lastActiveSlug) return;
        lastActiveSlug = currentSlug;
        tocLinks.forEach((link) => {
          const isActive = link.dataset.slug === currentSlug;
          link.classList.toggle('toc-active', isActive);
        });
        moveShellIndicator(currentSlug);
      };

      let headerObserver : IntersectionObserver | null = null;

      function initDynamicProgressBar() {
        const container = document.getElementById('dynamic-island-container');
        const header = document.getElementById('blog-header');
        
        if (!container || !header) {
          console.warn('DynamicProgressBar: dynamic-island-container or blog-header not found');
          return;
        }

        if (headerObserver) {
          headerObserver.disconnect();
        }

        headerObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (!entry.isIntersecting) {
                container.classList.remove('opacity-0', 'translate-y-[-20px]', 'pointer-events-none');
                if (isTocOpen) {
                  isTocOpen = false;
                  closeToc();
                }
              } else {
                container.classList.add('opacity-0', 'translate-y-[-20px]', 'pointer-events-none');
              }
            });
          },
          {
            threshold: 0,
            rootMargin: '0px',
          }
        );

        headerObserver.observe(header);
      }

      const handleScroll = () => {
        updateProgress();
        updateActiveHeading();
      };

      window.addEventListener('scroll', handleScroll);
      window.addEventListener('resize', () => {
        updateProgress();
        updateActiveHeading();
        if (isTocOpen && tocDropdown) {
          tocDropdown.style.maxHeight = `${clampTocHeight()}px`;
          setDropdownWidth(true);
          const targetWidth = measureExpandedWidth();
          if (dynamicContent) {
            (dynamicContent as HTMLElement).style.width = `${targetWidth}px`;
          }
        }
      });

      updateProgress();
      updateActiveHeading();
      initDynamicProgressBar();


      dynamicContent?.addEventListener('animationend', () => {
        dynamicContent.classList.remove('spring-open', 'spring-close');
      });

      dynamicContent?.addEventListener('transitionend', (e) => {
        if ((e as TransitionEvent).propertyName === 'width' && !isTocOpen) {
          (dynamicContent as HTMLElement).style.width = '';
        }
      });
  }
  
  document.addEventListener('astro:page-load', () => {
    console.log('astro:page-load');
    init();
  });
</script>

<style>
  #toc-dropdown::-webkit-scrollbar {
    width: 4px;
  }
  #toc-dropdown::-webkit-scrollbar-track {
    background: transparent;
  }
  #toc-dropdown::-webkit-scrollbar-thumb {
    background: rgba(var(--accent), 0.2);
    border-radius: 4px;
  }

  #toc-dropdown {
    width: 0;
    max-width: 0;
    will-change: max-height, opacity, transform, width;
  }

  .toc-link {
    transition: color 180ms ease, background-color 180ms ease;
  }

  .toc-link.toc-active {
    color: rgb(var(--foreground));
    background: rgba(var(--accent), 0.14);
  }

  .toc-link.toc-active:hover {
    background: rgba(var(--accent), 0.18);
  }

  #toc-shell-indicator {
    filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
  }

  .dynamic-island-content {
    transform-origin: top center;
    transition: width 260ms cubic-bezier(0.22, 1, 0.36, 1);
  }

  .dynamic-island-content.spring-open {
    animation: spring-open 380ms ease-in-out
  }

  .dynamic-island-content.spring-close {
    animation: spring-close 380ms ease-in-out;
  }

  @keyframes spring-open {
    45% { transform: scale(1.02, 1.04); }
    85% { transform: scale(0.995, 0.985); }
    100% { transform: scale(1); }
  }

  @keyframes spring-close {
    0% { transform: scale(1.01, 1.01); }
    10%  { transform: scale(1.04, 1.06); }
    35% { transform: scale(0.98, 0.94); }
    100% { transform: scale(1); }
  }
</style>
