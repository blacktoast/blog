---
import { Icon } from 'astro-icon/components';
import type { MarkdownHeading } from 'astro';

interface Props {
  title: string;
  headings: MarkdownHeading[];
}

const { title, headings } = Astro.props;
---

<div id="dynamic-island-container" class="fixed top-8 left-1/2 -translate-x-1/2 z-50 opacity-0 translate-y-[-20px] pointer-events-none">
  <div id="dynamic-island" class="relative group cursor-pointer">
    
    <div class="dynamic-island-content relative flex flex-col items-center px-4 py-2 bg-background/60 backdrop-blur-md border border-white/10 rounded-xl shadow-lg">
      <div class="dynamic-island-header flex items-center gap-3">
       <div class="relative w-5 h-5 flex items-center justify-center">
          <svg class="w-full h-full -rotate-90" viewBox="0 0 36 36">
          <path
            class="text-muted/20"
            d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
            fill="none"
            stroke="currentColor"
            stroke-width="4"
          />
          <path
            id="progress-circle"
            class="text-accent"
            stroke-dasharray="0, 100"
            d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
            fill="none"
            stroke="currentColor"
            stroke-width="4"
          />
        </svg>
      </div>
          <span class="text-sm font-medium truncate max-w-[200px] sm:max-w-[300px]">{title}</span>
          {
            headings.length > 0 && (
              <Icon name="lucide:chevron-down" class="w-4 h-4 text-muted-foreground transition-transform duration-300 group-[.open]:rotate-180" />
            )
          }
       </div>

       {
        headings.length > 0 && (
          <div
            id="toc-dropdown"
            class="pointer-events-none overflow-hidden origin-top"
            aria-hidden="true"
          >
          
            <nav id="toc-nav" class="relative flex flex-col gap-1 pt-1">
              <div
                id="toc-shell-indicator"
                class="absolute left-1 top-0 w-4 h-4 text-accent opacity-0 pointer-events-none will-change-transform"
                aria-hidden="true"
              >
                <div class="w-4 h-4 flex items-center justify-center">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M7 18 C 7 18 9 21 12 21 C 15 21 17 18 17 18" />
                    <path d="M17 18 C 20 16 22 13 21 9 C 20.5 7 19 4 12 3 C 5 4 3.5 7 3 9 C 2 13 4 16 7 18" />
                    <path d="M12 3 L 12 10" />      
                    <path d="M15.5 4 L 14.5 10.5" /> 
                    <path d="M8.5 4 L 9.5 10.5" />   
                    <path d="M19 8 L 16.5 13" />     
                    <path d="M5 8 L 7.5 13" />        
                </svg>
                </div>
              </div>
              <div class="w-1 h-1"/>
              {headings.filter(h => h.depth <= 3).map((heading) => (
                <a 
                  href={`#${heading.slug}`} 
                  class:list={[
                    "toc-link relative text-sm px-3 py-1.5 rounded-lg hover:bg-accent/10 transition-colors text-muted-foreground hover:text-foreground truncate block",
                    { "pl-7": heading.depth === 1, "pl-9": heading.depth === 2, "pl-12": heading.depth === 3 }
                  ]}
                  data-slug={heading.slug}
                >
                  {heading.text}
                </a>
              ))}
            </nav>
         </div>
        )
       }
    <!-- Table of Contents Dropdown -->
    
    </div>


  </div>
</div>

<script>
  import { animate, scroll, inView } from "motion";

  const init = () => {
    // 필수 요소
    const island = document.getElementById('dynamic-island');
    const container = document.getElementById('dynamic-island-container');
    const progressCircle = document.getElementById('progress-circle');
    const dynamicContent = document.querySelector('.dynamic-island-content') as HTMLElement;
    const headerRow = document.querySelector('.dynamic-island-header') as HTMLElement;
    const header = document.getElementById('blog-header');

    // TOC 관련 요소 (선택적)
    const tocDropdown = document.getElementById('toc-dropdown');
    const tocNav = document.getElementById('toc-nav');
    const shellIndicator = document.getElementById('toc-shell-indicator');
    const tocLinks = Array.from(document.querySelectorAll<HTMLAnchorElement>('#toc-dropdown nav a'));
    const hasToc = !!tocDropdown && tocLinks.length > 0;

    // 필수 요소 체크
    if (!island || !container || !dynamicContent || !headerRow) return;

    // 1. Scroll Progress (항상 실행)
    if (progressCircle) {
      scroll((progress: number) => {
        const scrolled = progress * 100;
        progressCircle.setAttribute('stroke-dasharray', `${scrolled}, 100`);
      });
    }

    // TOC 상태
    let isTocOpen = false;

    // 2. Show/Hide Island based on Header visibility
    if (header) {
      const checkInitialVisibility = () => {
        const rect = header.getBoundingClientRect();
        if (rect.bottom < 0) {
          animate(container, { 
            opacity: 1, 
            scale: [1.0, 1.04, 0.98, 1.0],
            pointerEvents: "auto" 
          }, { duration: 0.3 });
        }
      };
      checkInitialVisibility();

      inView(header, () => {
        animate(container, { 
          opacity: [0], 
          scale: [1, 0.8],
          pointerEvents: "none" 
        }, { duration: 0.3 });
        
        if (hasToc && isTocOpen) {
          toggleToc(false);
        }

        return () => {
          animate(container, { 
            opacity: 1, 
            scale: [1.0, 1.04, 0.98, 1.0],
            pointerEvents: "auto" 
          }, { duration: 0.3 });
        };
      });
    }

    // TOC가 없으면 여기서 종료
    if (!hasToc || !tocDropdown) return;

    // 3. TOC Logic
    const getHorizontalPadding = () => {
      const styles = getComputedStyle(dynamicContent);
      return parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
    };

    const measureCollapsedWidth = () => {
      const baseWidth = headerRow.getBoundingClientRect().width;
      return Math.ceil(baseWidth + getHorizontalPadding());
    };

    const measureExpandedWidth = () => {
      const prevWidth = tocDropdown.style.width;
      const prevMaxHeight = tocDropdown.style.maxHeight;
      const prevOpacity = tocDropdown.style.opacity;
      const prevDisplay = tocDropdown.style.display;
      
      tocDropdown.style.display = 'block';
      tocDropdown.style.width = 'max-content';
      tocDropdown.style.maxHeight = 'none';
      tocDropdown.style.opacity = '0';
      
      const dropdownWidth = tocDropdown.scrollWidth;
      const target = Math.max(measureCollapsedWidth(), Math.ceil(dropdownWidth + getHorizontalPadding()));
      
      tocDropdown.style.width = prevWidth;
      tocDropdown.style.maxHeight = prevMaxHeight;
      tocDropdown.style.opacity = prevOpacity;
      tocDropdown.style.display = prevDisplay;
      
      return target;
    };

    // 4. Active Heading & Shell Indicator
    const headingTargets = tocLinks
      .map((link) => {
        const slug = link.getAttribute('href')?.slice(1);
        return slug ? document.getElementById(slug) : null;
      })
      .filter((el): el is HTMLElement => Boolean(el));

    let currentActiveSlug: string | null = headingTargets[0]?.id ?? null;

    const moveShellIndicator = (slug: string | null) => {
      if (!shellIndicator || !tocNav) return;
      if (!slug) {
        animate(shellIndicator, { opacity: 0 }, { duration: 0.2 });
        return;
      }
      const activeLink = tocNav.querySelector<HTMLElement>(`a[data-slug="${slug}"]`);
      if (!activeLink) {
        animate(shellIndicator, { opacity: 0 }, { duration: 0.2 });
        return;
      }

      const navRect = tocNav.getBoundingClientRect();
      const linkRect = activeLink.getBoundingClientRect();
      const indicatorRect = shellIndicator.getBoundingClientRect();
      const offset = linkRect.top - navRect.top + (linkRect.height - indicatorRect.height) / 2;

      animate(shellIndicator, { 
        y: offset, 
        opacity: offset === 0 ? 0 : 1 
      }, { 
        type: "spring", 
        stiffness: 300, 
        damping: 30 
      });
    };

    const toggleToc = (open: boolean) => {
      isTocOpen = open;
      
      if (open) {
        island.classList.add('open');
        tocDropdown.setAttribute('aria-hidden', 'false');
        
        animate(dynamicContent, { 
          scale: [1, 1.02, 0.99, 1],
          width: `${measureExpandedWidth()}px`
        }, { 
          duration: 0.5,
          ease: [0.22, 1, 0.36, 1]
        });

        animate(tocDropdown, { 
          opacity: 1,
          height: "auto",
          width: "100%",
          display: "block",
          scale: 1,
          pointerEvents: "auto"
        }, { duration: 0.4, ease: [0.22, 1, 0.36, 1] }).finished.then(() => {
          moveShellIndicator(currentActiveSlug);
        });

      } else {
        island.classList.remove('open');
        tocDropdown.setAttribute('aria-hidden', 'true');

        animate(dynamicContent, { 
          scale: [1, 1.01, 0.98, 1],
          width: `${measureCollapsedWidth()}px`
        }, { 
          duration: 0.5,
          ease: [0.22, 1, 0.36, 1]
        });

        animate(tocDropdown, { 
          opacity: 0,
          height: 0,
          width: "100%",
          scale: 0.95,
          pointerEvents: "none"
        }, { duration: 0.3, ease: [0.22, 1, 0.36, 1] }).finished.then(() => {
          tocDropdown.style.display = "none";
        });
      }
    };

    const updateActiveHeading = () => {
      if (!headingTargets.length) return;
      
      const triggerY = window.innerHeight * 0.3;
      currentActiveSlug = headingTargets[0].id;
      
      for (const el of headingTargets) {
        const rect = el.getBoundingClientRect();
        if (rect.top <= triggerY) {
          currentActiveSlug = el.id;
        } else {
          break;
        }
      }

      tocLinks.forEach((link) => {
        const isActive = link.dataset.slug === currentActiveSlug;
        link.classList.toggle('toc-active', isActive);
      });
      if (isTocOpen) {
        moveShellIndicator(currentActiveSlug);
      }
    };

    // Event listeners
    island.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleToc(!isTocOpen);
    });

    document.addEventListener('click', (e) => {
      if (isTocOpen && !island.contains(e.target as Node)) {
        toggleToc(false);
      }
    });

    tocDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    window.addEventListener('scroll', updateActiveHeading, { passive: true });
    updateActiveHeading();
    
    window.addEventListener('resize', () => {
      if (isTocOpen) {
        animate(dynamicContent, { width: `${measureExpandedWidth()}px` }, { duration: 0 });
      }
    });
  };

  document.addEventListener('astro:page-load', () => {
    init();
  });
</script>

<style>
  #toc-dropdown::-webkit-scrollbar {
    width: 4px;
  }
  #toc-dropdown::-webkit-scrollbar-track {
    background: transparent;
  }
  #toc-dropdown::-webkit-scrollbar-thumb {
    background: rgba(var(--accent), 0.2);
    border-radius: 4px;
  }

  #toc-dropdown {
    display: none; /* Hidden by default, motion will handle display */
    height: 0;
    width: 0;
    opacity: 0;
  }

  .toc-link {
    transition: color 180ms ease, background-color 180ms ease;
  }

  .toc-link.toc-active {
    color: rgb(var(--foreground));
    background: rgba(var(--accent), 0.14);
  }

  .toc-link.toc-active:hover {
    background: rgba(var(--accent), 0.18);
  }

  #toc-shell-indicator {
    filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.15));
  }

  .dynamic-island-content {
    transform-origin: top center;
  }
</style>
